<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>우리 동네 경로 안내</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    #mic-btn {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 1002; background: #fff; border-radius: 50%; box-shadow: 0 4px 20px #0003;
      width: 90px; height: 90px; border: none; font-size: 45px; display: flex; align-items: center; justify-content: center;
      outline: none; cursor: pointer;
    }
    #choice-list {
      position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
      z-index: 1002; background: #fff; border-radius: 12px; padding: 18px; min-width: 220px;
      box-shadow: 0 4px 20px #0003; font-size: 18px; display: none;
    }
    .top-buttons { position: absolute; top: 10px; left: 10px; z-index: 1000; }
    #progress-box {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255, 255, 255, 0.9); padding: 8px 12px; border-radius: 8px; font-size: 14px; font-weight: bold;
    }
    button {
      margin: 4px; padding: 10px 15px; font-size: 16px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    #resetBtn { background-color: #c62828; color: white; }
    #sensorBtn { background-color: #2e7d32; color: white; }
    #compass-container {
      position: absolute; bottom: 20px; left: 50%;
      transform: translateX(-50%); z-index: 1001;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="mic-btn">🎤</button>
  <div id="choice-list"></div>
  <div class="top-buttons">
    <button id="sensorBtn">📱 방향 센서 활성화</button>
    <button id="resetBtn" onclick="resetMap()">🔄 초기화</button>
  </div>
  <div id="progress-box">진행률: -</div>
  <div id="compass-container"><canvas id="compassCanvas" width="200" height="200"></canvas></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // [1] 지도/기본 변수
    let map = L.map('map').setView([36.665, 127.493], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    const blueIcon = L.icon({ iconUrl: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png', iconSize: [32, 32], iconAnchor: [16, 32] });
    const redIcon = L.icon({ iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png', iconSize: [32, 32], iconAnchor: [16, 32] });
    let routeCoords = [], currentLatLng = null, currentMarker = null, startMarker = null, endMarker = null;
    let routeLine = null, traveledLine = null, closestIndex = 0;
    let deviceHeading = null, fixedTargetAngle = null, lastDirectionState = null;
    let directionMsgLock = false, lastAcceptedLatLng = null;

    // [2] 위험지역 좌표 예시 (생략, 필요시 추가)
    // ...

    // [3] 음성안내 함수
    function speak(text) {
      if (directionMsgLock) return;
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'ko-KR';
      speechSynthesis.speak(utterance);
      directionMsgLock = true;
      setTimeout(() => { directionMsgLock = false; }, 2000);
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180, toDeg = rad => rad * 180 / Math.PI;
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371000, toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function drawCompass(targetAngle, tolerance, currentAngle) {
      tolerance = 12;
      const canvas = document.getElementById("compassCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 200, 200);
      const centerX = 100, centerY = 100, radius = 90;
      const offset = -120;
      const adjTarget = (targetAngle + offset + 360) % 360;
      const startRad = ((adjTarget - tolerance + 360) % 360) * Math.PI / 180;
      const endRad = ((adjTarget + tolerance + 360) % 360) * Math.PI / 180;

      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startRad, endRad);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
      ctx.fill();

      const angleRad = (currentAngle - 90) * Math.PI / 180;
      const x = centerX + radius * Math.cos(angleRad);
      const y = centerY + radius * Math.sin(angleRad);

      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(x, y);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    function handleOrientation(event) {
      if (event.webkitCompassHeading !== undefined) {
        deviceHeading = event.webkitCompassHeading;
      } else if (event.alpha !== null) {
        deviceHeading = 360 - event.alpha;
      }
    }
    function requestSensorPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
          if (state === 'granted') window.addEventListener("deviceorientation", handleOrientation);
        }).catch(console.error);
      } else window.addEventListener("deviceorientation", handleOrientation);
    }
    document.getElementById("sensorBtn").addEventListener("click", requestSensorPermission);

    function resetMap() {
      routeCoords = [];
      if (routeLine) map.removeLayer(routeLine);
      if (traveledLine) map.removeLayer(traveledLine);
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);
      routeLine = traveledLine = startMarker = endMarker = null;
      document.getElementById("progress-box").innerText = "진행률: -";
      lastDirectionState = null;
      lastAcceptedLatLng = null;
      document.getElementById("choice-list").style.display = "none";
      document.getElementById("mic-btn").style.display = "flex";
    }

    function getRoute(start, end) {
      const url = `https://router.project-osrm.org/route/v1/walking/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`;
      fetch(url).then(res => res.json()).then(data => {
        const coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
        routeCoords = coords;
        routeLine = L.polyline(coords, { color: 'blue' }).addTo(map);
        map.fitBounds(routeLine.getBounds());
        speak("경로를 안내합니다.");
        document.getElementById("mic-btn").style.display = "none";
        document.getElementById("choice-list").style.display = "none";
      });
    }

    // [4] GPS 위치 트래킹
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        pos => {
          const newLatLng = [pos.coords.latitude, pos.coords.longitude];
          if (lastAcceptedLatLng) {
            const d = distance(lastAcceptedLatLng[0], lastAcceptedLatLng[1], newLatLng[0], newLatLng[1]);
            if (d > 30) return;
          }
          lastAcceptedLatLng = newLatLng;
          currentLatLng = newLatLng;

          if (!currentMarker) {
            currentMarker = L.marker(currentLatLng).addTo(map);
            map.setView(currentLatLng, 16);
            if (!startMarker) {
              startMarker = L.marker(currentLatLng, { icon: blueIcon }).addTo(map);
              speak("출발지로 현재 위치를 설정했습니다. 도착지를 검색해주세요.");
            }
          } else currentMarker.setLatLng(currentLatLng);

          if (routeCoords.length > 1) {
            let minDist = Infinity;
            for (let i = 0; i < routeCoords.length; i++) {
              const d = distance(currentLatLng[0], currentLatLng[1], routeCoords[i][0], routeCoords[i][1]);
              if (d < minDist) {
                minDist = d;
                closestIndex = i;
              }
            }
            const progress = Math.round((closestIndex / (routeCoords.length - 1)) * 100);
            document.getElementById("progress-box").innerText = `진행률: ${progress}%`;
            const traveled = routeCoords.slice(0, closestIndex + 1);
            if (traveledLine) traveledLine.setLatLngs(traveled);
            else traveledLine = L.polyline(traveled, { color: "green" }).addTo(map);
          }

          if (routeCoords.length > 1 && closestIndex < routeCoords.length - 1) {
            const next = routeCoords[closestIndex + 1];
            fixedTargetAngle = calculateBearing(currentLatLng[0], currentLatLng[1], next[0], next[1]);
          }
        },
        null,
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
      );
    }

    function updateCompassAlways() {
      if (deviceHeading === null || fixedTargetAngle === null) return;
      drawCompass(fixedTargetAngle, 12, deviceHeading);
      const diff = Math.abs(fixedTargetAngle - deviceHeading);
      const angleDiff = Math.min(diff, 360 - diff);
      const isCorrect = angleDiff <= 12;
      if (isCorrect !== lastDirectionState) {
        if (isCorrect) {
          speak("방향이 맞았습니다. 계속 이동하세요.");
        } else {
          speak("방향이 틀렸습니다. 화살표를 초록색 안으로 돌려주세요.");
        }
        lastDirectionState = isCorrect;
      }
    }
    setInterval(updateCompassAlways, 2000);

    // [5] 음성 인식 & 카카오 API 검색 및 안내
    const micBtn = document.getElementById("mic-btn");
    const choiceListDiv = document.getElementById("choice-list");

    let places = [];
    let selectedPlace = null;

    function correctKoreanSpacing(str) {
      // 띄어쓰기 교정 간이버전(실제론 외부 라이브러리 필요)
      return str.replace(/([가-힣])([A-Z])/g, "$1 $2").trim();
    }

    function startVoiceRecognition() {
      if (!('webkitSpeechRecognition' in window)) {
        alert('브라우저가 음성인식을 지원하지 않습니다.');
        return;
      }
      micBtn.innerText = '🎤 듣는중...';
      micBtn.disabled = true;
      const recognition = new webkitSpeechRecognition();
      recognition.lang = 'ko-KR';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.start();

      recognition.onresult = function(event) {
        let transcript = event.results[0][0].transcript.trim();
        transcript = correctKoreanSpacing(transcript);
        speak('검색어: ' + transcript + ', 맞습니까?');
        setTimeout(() => { searchPlace(transcript); }, 1800);
      };
      recognition.onerror = function() {
        speak("음성 인식에 실패했습니다. 다시 시도해주세요.");
        micBtn.innerText = '🎤';
        micBtn.disabled = false;
      };
      recognition.onend = function() {
        micBtn.innerText = '🎤';
        micBtn.disabled = false;
      };
    }

    async function searchPlace(keyword) {
      // (실제 배포시 키 노출 위험, 서버프록시 추천) REST API 키!
      const KAKAO_REST_API_KEY = "5149a6f2dc9c675321b19bbea6e0968a";
      let location = currentLatLng ? `${currentLatLng[1]},${currentLatLng[0]}` : "127.493,36.665";
      const url = `https://dapi.kakao.com/v2/local/search/keyword.json?query=${encodeURIComponent(keyword)}&y=${currentLatLng ? currentLatLng[0] : 36.665}&x=${currentLatLng ? currentLatLng[1] : 127.493}&radius=2000&size=5`;
      const response = await fetch(url, {
        headers: { "Authorization": "KakaoAK " + KAKAO_REST_API_KEY }
      });
      const data = await response.json();
      if (data.documents && data.documents.length > 0) {
        places = data.documents;
        let listHtml = "<b>가까운 결과:</b><br>";
        places.forEach((p, idx) => {
          listHtml += `${idx+1}. ${p.place_name} (${p.road_address_name || p.address_name})<br>`;
        });
        listHtml += "<br>원하는 장소의 번호를 말씀해주세요.";
        choiceListDiv.innerHTML = listHtml;
        choiceListDiv.style.display = "block";
        speak(places.map((p,i)=>`${i+1}번 ${p.place_name}`).join(', ') + "중에, 원하는 번호를 말씀해주세요.");
        listenChoice();
      } else {
        choiceListDiv.innerHTML = "검색 결과가 없습니다.<br>다시 시도해주세요.";
        choiceListDiv.style.display = "block";
        speak("검색 결과가 없습니다. 다시 말씀해주세요.");
        micBtn.style.display = "flex";
      }
    }

    function listenChoice() {
      if (!('webkitSpeechRecognition' in window)) return;
      const recognition = new webkitSpeechRecognition();
      recognition.lang = 'ko-KR';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.start();

      recognition.onresult = function(event) {
        let transcript = event.results[0][0].transcript.trim();
        let num = transcript.match(/[0-9]+/);
        if (!num) {
          // 번호가 아니면 이름 중에서 유사한 것 선택
          let idx = places.findIndex(p => transcript.replace(/ /g,"").includes(p.place_name.replace(/ /g,"")));
          if (idx >= 0) num = [idx+1];
        }
        if (num && num[0] >= 1 && num[0] <= places.length) {
          selectedPlace = places[num[0]-1];
          speak(`선택하신 곳은 ${selectedPlace.place_name}, 맞으면 잠시만 기다려주세요.`);
          setTimeout(() => {
            // 도착지 마커 표시 및 경로 안내
            if (endMarker) { map.removeLayer(endMarker); }
            endMarker = L.marker([selectedPlace.y, selectedPlace.x], { icon: redIcon }).addTo(map);
            getRoute([startMarker.getLatLng().lat, startMarker.getLatLng().lng], [Number(selectedPlace.y), Number(selectedPlace.x)]);
            choiceListDiv.style.display = "none";
            micBtn.style.display = "none";
          }, 2500);
        } else {
          speak("다시 번호를 말씀해주세요.");
          listenChoice();
        }
      };
      recognition.onerror = function() {
        speak("선택 음성 인식에 실패했습니다. 다시 말씀해주세요.");
        listenChoice();
      };
    }

    micBtn.addEventListener("click", function() {
      speak
