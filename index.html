<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ìš°ë¦¬ ë™ë„¤ ê²½ë¡œ ì•ˆë‚´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=c3538b3d362494aa354799bac1a30973&libraries=services"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .top-buttons {
      position: absolute; top: 10px; left: 10px; z-index: 1000; display: none;
    }
    #progress-box {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255,255,255,0.9); padding: 8px 12px;
      border-radius: 8px; font-size: 14px; font-weight: bold;
    }
    button {
      margin: 4px; padding: 10px 15px; font-size: 16px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    #resetBtn { background-color: #c62828; color: white; }
    #sensorBtn { background-color: #2e7d32; color: white; }
    #compass-container {
      position: absolute; bottom: 20px; left: 50%;
      transform: translateX(-50%); z-index: 1001;
    }
    #micBtn {
      position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 140px; height: 140px; border-radius: 100px;
      font-size: 60px; background: #1de9b6; color: white; border: none;
      box-shadow: 0 0 20px #0004; z-index: 2000;
    }
    #voiceStatus {
      position: absolute; top: 67%; left: 50%; transform: translateX(-50%);
      font-size: 1.2em; background: #fff9; padding: 10px 24px; border-radius: 20px;
      z-index: 2100; text-align: center; min-width: 160px;
    }
    #search-box {
      position: absolute; left: 20px; bottom: 20px; z-index: 3000; background: #fff9;
      border-radius: 8px; padding: 10px 12px; box-shadow: 0 0 6px #0002;
    }
    #results {
      position: absolute; left: 20px; bottom: 70px; z-index: 3000; background: #fff9;
      border-radius: 8px; padding: 6px 12px; min-width: 230px; list-style: none;
      font-size: 1em; max-height: 180px; overflow-y: auto;
    }
    #results li { margin: 2px 0; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="top-buttons">
    
    <button id="resetBtn" onclick="resetMap()">ğŸ”„ ì´ˆê¸°í™”</button>
  </div>
  <div id="progress-box">ì§„í–‰ë¥ : -</div>
  <div id="compass-container">
    <canvas id="compassCanvas" width="200" height="200"></canvas>
  </div>
  <button id="micBtn">ğŸ¤</button>
  <div id="voiceStatus" style="display:none"></div>
 
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ===== ì§€ë„ & ìœ„í—˜êµ¬ê°„ =====
    let map = L.map('map').setView([36.665, 127.493], 15);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);
    const blueIcon = L.icon({ iconUrl: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png', iconSize: [32,32], iconAnchor: [16,32] });
    const redIcon = L.icon({ iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png', iconSize: [32,32], iconAnchor: [16,32] });

    let routeCoords=[], currentLatLng=null, currentMarker=null, startMarker=null, endMarker=null;
    let routeLine=null, traveledLine=null, closestIndex=0;
    let deviceHeading=null, fixedTargetAngle=null, lastToldCorrect=null;
    let directionMsgLock=false, lastAcceptedLatLng=null;

    // ìœ„í—˜ì§€ì—­ ì˜ˆì‹œ (ê³ ì •)
    const dangerZones = [
      { lat: 36.6718218309183, lon: 127.48441647091, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6691856859285, lon: 127.484526668822, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6681198498837, lon: 127.485241335168, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6664434295902, lon: 127.479875756191, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6664882385441, lon: 127.479760574661, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6643897168371, lon: 127.493174822168, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6585208580266, lon: 127.514097203935, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6665694566346, lon: 127.47992811047, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6688643206019, lon: 127.489874115027, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6712011365218, lon: 127.497653699119, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.672340736864, lon: 127.497715232727, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.671208751872, lon: 127.497474561309, msg: "ìœ„í—˜ì§€ì—­" },
      { lat: 36.6634181065428, lon: 127.474129870281, msg: "ìœ„í—˜ì§€ì—­" }
    ];
    const CATEGORY_WORDS = [
      "ì•½êµ­", "í¸ì˜ì ", "ì¹´í˜", "ì‹ë‹¹", "ë§ˆíŠ¸", "ë³‘ì›", "ì€í–‰", "ë„ì„œê´€", "í•™êµ", "ì•„íŒŒíŠ¸"
    ];

    // ==== ìŒì„±ì¸ì‹, ì•ˆë‚´, í›„ë³´ ====
    let voiceStep=0, candidates=[], selectedCand=null, finalLatLng=null;

 // [ìˆ˜ì • ì‹œì‘] speak í•¨ìˆ˜
function speak(text) {
  // ê¸°ì¡´ ì•ˆë‚´ ì¤‘ì´ë©´ ê°•ì œ ì¤‘ë‹¨!
  if (speechSynthesis.speaking) {
    speechSynthesis.cancel();
    directionMsgLock = false;
  }
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'ko-KR';
  utterance.onend = () => { directionMsgLock = false; };
  speechSynthesis.speak(utterance);
  directionMsgLock = true;
}
// [ìˆ˜ì • ë]

    // ìŒì„±ì¸ì‹
    function startSpeechRecognition(promptText) {
      let micBtn = document.getElementById('micBtn');
      let voiceDiv = document.getElementById('voiceStatus');
      micBtn.style.display = 'block';
      voiceDiv.style.display = 'block';
      voiceDiv.innerText = promptText;

      if (!('webkitSpeechRecognition' in window)) {
        alert('ìŒì„±ì¸ì‹ì´ ì§€ì›ë˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.');
        return;
      }
      let recognition = new webkitSpeechRecognition();
      recognition.lang = 'ko-KR';
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;
      recognition.start();

      recognition.onresult = (event) => {
        let transcript = event.results[0][0].transcript.trim();
        voiceDiv.innerText = "ì¸ì‹ê²°ê³¼: " + transcript;
        recognition.stop();
        setTimeout(() => onSpeechResult(transcript), 800);
      };
      recognition.onerror = (event) => {
        voiceDiv.innerText = "ìŒì„± ì¸ì‹ ì˜¤ë¥˜. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.";
        recognition.stop();
      };
    }

    function correctInput(txt) {
      return txt.trim().replace(/\s+/g, "");
    }
    function getJosa(word) {
  // í•œê¸€ì˜ ë§ˆì§€ë§‰ ê¸€ìë¥¼ ì¶”ì¶œí•´ì„œ ìœ ë‹ˆì½”ë“œê°’ ê³„ì‚°
      const lastChar = word[word.length - 1];
      const code = lastChar.charCodeAt(0);
      if (code < 0xAC00 || code > 0xD7A3) return "ë¡œ";
      const jong = (code - 0xAC00) % 28;
      if (jong === 0 || jong === 8) return "ë¡œ";
      return "ìœ¼ë¡œ";
    }


    // ==== ì¹´ì¹´ì˜¤ JS SDKë¡œ ì¥ì†Œ ê²€ìƒ‰ ====
    function searchCandidates(keyword, callback) {
      let lat = currentLatLng ? currentLatLng[0] : 36.665;
      let lon = currentLatLng ? currentLatLng[1] : 127.493;
      let ps = new kakao.maps.services.Places();
      let loc = new kakao.maps.LatLng(lat, lon);
      ps.keywordSearch(keyword, function(data, status) {
        if (status === kakao.maps.services.Status.OK) {
          callback(data.map(doc => ({
            name: doc.place_name,
            dist: doc.distance ? Number(doc.distance) : 0,
            lat: Number(doc.y),
            lon: Number(doc.x),
            addr: doc.road_address_name || doc.address_name
          })));
        } else {
          callback([]);
        }
      }, { location: loc, radius: 2000, size: 5 });
    }

function onSpeechResult(transcript) {
  let clean = correctInput(transcript);
  let voiceDiv = document.getElementById('voiceStatus'); 
  let micBtn = document.getElementById('micBtn');

  // [ìˆ˜ì • ì‹œì‘] ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” í›„ë³´ê°€ ìˆìœ¼ë©´ ë°”ë¡œ ì˜ˆ/ì•„ë‹ˆì˜¤ë¡œ ì•ˆë‚´
  if (voiceStep === 0) {
  searchCandidates(clean, function(found) {
    candidates = found;
    if (candidates.length === 0) {
      speak("ê·¼ì²˜ì— í•´ë‹¹í•˜ëŠ” ì¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë§ì”€í•´ ì£¼ì„¸ìš”.");
      setTimeout(() => startSpeechRecognition("ë„ì°©ì§€ë¥¼ ë‹¤ì‹œ ë§ì”€í•´ ì£¼ì„¸ìš”."), 2000);
      return;
    }

    let userWord = clean.replace(/[\s\W]/g, "");
    let isCategory = CATEGORY_WORDS.some(cat => cat.replace(/[\s\W]/g, "") === userWord);
    console.log("[ë””ë²„ê·¸] userWord:", userWord, "isCategory:", isCategory);

    if (isCategory) {
      let candText = candidates.map((c, i) => `${i+1}ë²ˆ ${c.name} ${c.dist}ë¯¸í„°`).join(", ");
      speak(`ê·¼ì²˜ì— ${candText}ê°€ ìˆìŠµë‹ˆë‹¤. ì›í•˜ëŠ” ë²ˆí˜¸ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”.`);
      voiceDiv.innerText = `í›„ë³´: ${candText}\në²ˆí˜¸ ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ë§ì”€í•˜ì„¸ìš”.`;
      voiceStep = 1;
      setTimeout(() => startSpeechRecognition("ì›í•˜ëŠ” ë²ˆí˜¸ë‚˜ ì´ë¦„ì„ ë§ì”€í•´ ì£¼ì„¸ìš”."), 3500);
      return;
    }


    // â˜… 2. ê³ ìœ ëª…ì‚¬(ì •í™•íˆ ì¼ì¹˜)ë¡œ ë§í•œ ê²½ìš° â†’ ì˜ˆ/ì•„ë‹ˆì˜¤ ì•ˆë‚´
    // (ë‹¨, ë²”ì£¼ ë‹¨ì–´ì™€ ê°™ìœ¼ë©´ ì—¬ê¸° ì•ˆ ë“¤ì–´ì˜´)
    let exactMatch = candidates.find(c =>
      c.name.replace(/[\s\W]/g, "") === userWord
    );
    if (exactMatch) {
      selectedCand = exactMatch;
      const josa = getJosa(exactMatch.name);
      speak(`${exactMatch.name}${josa} ì•ˆë‚´ë¥¼ ì‹œì‘í• ê¹Œìš”? ì˜ˆ ë˜ëŠ” ì•„ë‹ˆì˜¤ë¡œ ëŒ€ë‹µí•´ ì£¼ì„¸ìš”.`);
      voiceDiv.innerText = `${exactMatch.name}${josa} ì•ˆë‚´ ì‹œì‘? (ì˜ˆ/ì•„ë‹ˆì˜¤)`;
      voiceStep = 2;
      setTimeout(() => startSpeechRecognition("ì˜ˆ, ì•„ë‹ˆì˜¤ë¡œ ëŒ€ë‹µí•´ ì£¼ì„¸ìš”."), 3500);
      return;
    }

    // 3. ê·¸ ì™¸ëŠ” ê¸°ì¡´ ë°©ì‹
    let candText = candidates.map((c, i) => `${i+1}ë²ˆ ${c.name} ${c.dist}ë¯¸í„°`).join(", ");
    speak(`ê·¼ì²˜ì— ${candText}ê°€ ìˆìŠµë‹ˆë‹¤. ì›í•˜ëŠ” ë²ˆí˜¸ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”.`);
    voiceDiv.innerText = `í›„ë³´: ${candText}\në²ˆí˜¸ ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ë§ì”€í•˜ì„¸ìš”.`;
    voiceStep = 1;
    setTimeout(() => startSpeechRecognition("ì›í•˜ëŠ” ë²ˆí˜¸ë‚˜ ì´ë¦„ì„ ë§ì”€í•´ ì£¼ì„¸ìš”."), 3500);
  });
} else if (voiceStep === 1) {
    let num = parseInt(clean.replace(/[^0-9]/g, ""));
    // "ì´ë²ˆ"ì„ 2ë²ˆìœ¼ë¡œ ì²˜ë¦¬
    if (clean.includes("ì´ë²ˆ")) {
      num = 2;
    }
    let chosen = null;
    if (!isNaN(num) && num > 0 && num <= candidates.length) {
      chosen = candidates[num - 1];
    } else {
      chosen = candidates.find(c => clean.includes(c.name.replace(/\s/g, "")));
    }
    if (!chosen) {
      speak("ì¸ì‹ ê²°ê³¼ì— í•´ë‹¹í•˜ëŠ” í›„ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë§ì”€í•´ ì£¼ì„¸ìš”.");
      setTimeout(() => startSpeechRecognition("ì›í•˜ëŠ” ì¥ì†Œì˜ ë²ˆí˜¸ë‚˜ ì´ë¦„ì„ ë§ì”€í•´ ì£¼ì„¸ìš”."), 2000);
      return;
    }
    selectedCand = chosen;
    const josa = getJosa(chosen.name);
    speak(`${chosen.name}${josa} ì•ˆë‚´ë¥¼ ì‹œì‘í• ê¹Œìš”? ì˜ˆ ë˜ëŠ” ì•„ë‹ˆì˜¤ë¡œ ëŒ€ë‹µí•´ ì£¼ì„¸ìš”.`);
    voiceDiv.innerText = `${chosen.name}${josa} ì•ˆë‚´ ì‹œì‘? (ì˜ˆ/ì•„ë‹ˆì˜¤)`;
    voiceStep = 2;
    setTimeout(() => startSpeechRecognition("ì˜ˆ, ì•„ë‹ˆì˜¤ë¡œ ëŒ€ë‹µí•´ ì£¼ì„¸ìš”."), 3500);
  } else if (voiceStep === 2) {
    let yes = ["ë„¤","ì˜ˆ","ì‘","ë§ì•„","ì˜ˆìŠ¤","okay","ì¢‹ì•„"];
    if (yes.some(word => clean.includes(word))) {
      speak(`${selectedCand.name}${getJosa(selectedCand.name)} ê¸¸ ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.`);
      finalLatLng = [selectedCand.lat, selectedCand.lon];
      micBtn.style.display = 'none';
      voiceDiv.style.display = 'none';
      setTimeout(() => {
        document.querySelector('.top-buttons').style.display = "block";
        if (!startMarker && currentLatLng) {
          startMarker = L.marker(currentLatLng, { icon: blueIcon }).addTo(map);
        }
        endMarker = L.marker(finalLatLng, { icon: redIcon }).addTo(map);
        getRoute(currentLatLng, finalLatLng);
      }, 1800);
      voiceStep = 0;
    } else {
      speak("ë‹¤ì‹œ ì²˜ìŒë¶€í„° ì„ íƒì„ ì‹œì‘í•©ë‹ˆë‹¤.");
      voiceStep = 0;
      selectedCand = null;
      setTimeout(() => startSpeechRecognition("ë„ì°©ì§€ë¥¼ ë‹¤ì‹œ ë§ì”€í•´ ì£¼ì„¸ìš”."), 2000);
    }
  }
}

    document.getElementById("micBtn").onclick = () => {
      voiceStep=0; candidates=[]; selectedCand=null; finalLatLng=null;
      speak("ë„ì°©ì§€ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”");
      startSpeechRecognition("ë„ì°©ì§€ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”. ì˜ˆ: ì•½êµ­, í¸ì˜ì , ì¹´í˜");
    };

    // ìœ„í—˜ì§€ì—­ ë§ˆì»¤ í‘œì‹œ
    function showDangerMarkers() {
      if (window.dangerMarkers) window.dangerMarkers.forEach(m => map.removeLayer(m));
      window.dangerMarkers = [];
      dangerZones.forEach(pt => {
        const marker = L.marker([Number(pt.lat), Number(pt.lon)], {
          icon: L.divIcon({
            className: 'custom-div-icon',
            html: `<img src="https://cdn-icons-png.flaticon.com/512/564/564619.png" width="16" height="16">`,
            iconSize: [16,16], iconAnchor: [8,8]
          })
        }).addTo(map).bindPopup(pt.msg);
        window.dangerMarkers.push(marker);
      });
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180, toDeg = rad => rad * 180 / Math.PI;
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371000, toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // == ë‚˜ì¹¨ë°˜(ë¶€ì±„ê¼´=ëª©í‘œ, ì¹¨=í˜„ìœ„ì¹˜), offset ì—†ì´
    function drawCompass(targetAngle, tolerance, currentAngle) {
      tolerance = 20;
      const canvas = document.getElementById("compassCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,200,200);
      const centerX=100, centerY=100, radius=90;
      // ë¶€ì±„ê¼´(ëª©í‘œë°©í–¥, 0ë„ê°€ ìœ„ìª½)
      const startRad = ((targetAngle-tolerance-90)*Math.PI/180);
      const endRad = ((targetAngle+tolerance-90)*Math.PI/180);
      ctx.beginPath(); ctx.arc(centerX,centerY,radius,0,2*Math.PI);
      ctx.strokeStyle="#555"; ctx.lineWidth=2; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(centerX,centerY);
      ctx.arc(centerX,centerY,radius,startRad,endRad); ctx.lineTo(centerX,centerY);
      ctx.fillStyle="rgba(0,255,0,0.3)"; ctx.fill();
      // ì¹¨(í˜„ì¬ë°©í–¥)
      const angleRad=(currentAngle-90)*Math.PI/180;
      const x=centerX+radius*Math.cos(angleRad), y=centerY+radius*Math.sin(angleRad);
      ctx.beginPath(); ctx.moveTo(centerX,centerY); ctx.lineTo(x,y);
      ctx.strokeStyle="red"; ctx.lineWidth=4; ctx.stroke();
    }

    // [ìˆ˜ì • ì‹œì‘] updateCompassAlways í•¨ìˆ˜
function updateCompassAlways() {
  if (deviceHeading === null || fixedTargetAngle === null) return;
  const tolerance = 20;
  drawCompass(fixedTargetAngle, tolerance, deviceHeading);
  let diff = Math.abs(fixedTargetAngle - deviceHeading);
  let angleDiff = Math.min(diff, 360 - diff);
  let isCorrect = angleDiff <= tolerance;

  // â˜… ìƒíƒœ ë³€í™”(ë§â†”í‹€)ì‹œ ì¦‰ê° í”¼ë“œë°±
  if (isCorrect !== lastToldCorrect) {
    if (isCorrect) {
      speak("ë°©í–¥ì´ ë§ì•˜ìŠµë‹ˆë‹¤. ê³„ì† ì´ë™í•˜ì„¸ìš”.");
    } else {
      speak("ë°©í–¥ì´ í‹€ë ¸ìŠµë‹ˆë‹¤. í™”ì‚´í‘œë¥¼ ì´ˆë¡ìƒ‰ ì•ˆìœ¼ë¡œ ëŒë ¤ì£¼ì„¸ìš”.");
    }
    lastToldCorrect = isCorrect;
    return;
  }

  // í‹€ë¦° ìƒíƒœê°€ ì§€ì†ë˜ë©´ ê³„ì† ì•ˆë‚´
  if (!isCorrect && !directionMsgLock) {
    speak("ë°©í–¥ì´ í‹€ë ¸ìŠµë‹ˆë‹¤. í™”ì‚´í‘œë¥¼ ì´ˆë¡ìƒ‰ ì•ˆìœ¼ë¡œ ëŒë ¤ì£¼ì„¸ìš”.");
  }
}
// [ìˆ˜ì • ë]
    setInterval(updateCompassAlways, 2000);

    // ===== ê²€ìƒ‰ ë°•ìŠ¤ ê¸°ëŠ¥ =====
    function searchPlaces() {
      let q = document.getElementById('query').value;
      let lat = currentLatLng ? currentLatLng[0] : 36.665;
      let lon = currentLatLng ? currentLatLng[1] : 127.493;
      fetch(`/search?query=${encodeURIComponent(q)}&lat=${lat}&lon=${lon}`)
        .then(res => res.json())
        .then(data => {
          let ul = document.getElementById('results');
          ul.innerHTML = "";
          if(data.documents && data.documents.length > 0) {
            data.documents.forEach(doc => {
              let li = document.createElement('li');
              li.textContent = `${doc.place_name} (${doc.address_name}) - ${doc.distance}m`;
              ul.appendChild(li);
            });
          } else {
            ul.innerHTML = "<li>ê·¼ì²˜ì— í•´ë‹¹í•˜ëŠ” ì¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.</li>";
          }
        });
    }

    // ìœ„ì¹˜ ì¶”ì /ê²½ë¡œ ì•ˆë‚´ ë“±ì€ ê¸°ì¡´ ì½”ë“œ ë™ì¼
    function handleOrientation(event) {
      if (event.webkitCompassHeading !== undefined) {
        deviceHeading = event.webkitCompassHeading;
      } else if (event.alpha !== null) {
        deviceHeading = 360 - event.alpha;
      }
    }
    function requestSensorPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
          if (state === 'granted') window.addEventListener("deviceorientation", handleOrientation);
        }).catch(console.error);
      } else window.addEventListener("deviceorientation", handleOrientation);
    }
    // [ì—¬ê¸° ì¶”ê°€]
    window.addEventListener("DOMContentLoaded", () => {
      requestSensorPermission();
    });

    function resetMap() {
      routeCoords = [];
      if (routeLine) map.removeLayer(routeLine);
      if (traveledLine) map.removeLayer(traveledLine);
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);
      routeLine = traveledLine = startMarker = endMarker = null;
      document.getElementById("progress-box").innerText = "ì§„í–‰ë¥ : -";
      lastToldCorrect = null; lastAcceptedLatLng = null;
      showDangerMarkers();
      document.querySelector('.top-buttons').style.display = "none";
      document.getElementById('micBtn').style.display = 'block';
      document.getElementById('voiceStatus').style.display = 'block';
      voiceStep=0; candidates=[]; selectedCand=null; finalLatLng=null;
      speak("ë„ì°©ì§€ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”");
      setTimeout(() => startSpeechRecognition("ë„ì°©ì§€ë¥¼ ë§ì”€í•´ ì£¼ì„¸ìš”. ì˜ˆ: ì•½êµ­, í¸ì˜ì , ì¹´í˜"), 1000);
    }

    function getRoute(start, end) {
      const url = `https://router.project-osrm.org/route/v1/walking/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`;
      fetch(url).then(res=>res.json()).then(data=>{
        const coords = data.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]);
        routeCoords=coords;
        routeLine = L.polyline(coords, { color:'blue' }).addTo(map);
        map.fitBounds(routeLine.getBounds());
        speak("ê²½ë¡œë¥¼ ì•ˆë‚´í•©ë‹ˆë‹¤."); showDangerMarkers();
      });
    }

    // GPS ìœ„ì¹˜ íŠ¸ë˜í‚¹
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        pos => {
          const newLatLng = [pos.coords.latitude, pos.coords.longitude];
          if (lastAcceptedLatLng) {
            const d = distance(lastAcceptedLatLng[0], lastAcceptedLatLng[1], newLatLng[0], newLatLng[1]);
            if (d > 30) return;
          }
          lastAcceptedLatLng = newLatLng; currentLatLng = newLatLng;
          if (!currentMarker) {
            currentMarker = L.marker(currentLatLng).addTo(map);
            map.setView(currentLatLng, 16);
            if (!startMarker) {
              startMarker = L.marker(currentLatLng, { icon: blueIcon }).addTo(map);
            }
          } else currentMarker.setLatLng(currentLatLng);
          if (routeCoords.length > 1) {
            let minDist = Infinity;
            for (let i = 0; i < routeCoords.length; i++) {
              const d = distance(currentLatLng[0], currentLatLng[1], routeCoords[i][0], routeCoords[i][1]);
              if (d < minDist) { minDist = d; closestIndex = i; }
            }
            const progress = Math.round((closestIndex / (routeCoords.length - 1)) * 100);
            document.getElementById("progress-box").innerText = `ì§„í–‰ë¥ : ${progress}%`;
            const traveled = routeCoords.slice(0, closestIndex + 1);
            if (traveledLine) traveledLine.setLatLngs(traveled);
            else traveledLine = L.polyline(traveled, { color: "green" }).addTo(map);
          }
          if (routeCoords.length > 1 && closestIndex < routeCoords.length - 1) {
            const next = routeCoords[closestIndex + 1];
            fixedTargetAngle = calculateBearing(currentLatLng[0], currentLatLng[1], next[0], next[1]);
          }
        },
        null,
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
      );
    }

    showDangerMarkers();
  </script>
</body>
</html>
