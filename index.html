<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ìš°ë¦¬ ë™ë„¤ ê²½ë¡œ ì•ˆë‚´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }
    .top-buttons {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
    }
    #progress-box {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255, 255, 255, 0.9); padding: 8px 12px;
      border-radius: 8px; font-size: 14px; font-weight: bold;
    }
    button {
      margin: 4px; padding: 10px 15px; font-size: 16px;
      border: none; border-radius: 5px; cursor: pointer;
    }
    #resetBtn { background-color: #c62828; color: white; }
    #sensorBtn { background-color: #2e7d32; color: white; }
    #compass-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="top-buttons">
    <button id="sensorBtn">ğŸ“¡ ë°©í–¥ ì„¼ì„œ í™œì„±í™”</button>
    <button id="resetBtn" onclick="resetMap()">ğŸ”„ ì´ˆê¸°í™”</button>
  </div>
  <div id="progress-box">ì§„í–‰ë¥ : -</div>
  <div id="compass-container">
    <canvas id="compassCanvas" width="200" height="200"></canvas>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ì§€ë„ ì´ˆê¸°í™”
    let map = L.map('map').setView([0, 0], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19
    }).addTo(map);

    // ì „ì—­ ë³€ìˆ˜
    let routeCoords = [];
    let turnPoints = []; // í„´ ì§€ì  ëª©ë¡
    let currentLatLng = null;
    let routeLine = null;
    let traveledLine = null;
    let startMarker = null;
    let endMarker = null;
    let currentMarker = null;
    let fixedTargetAngle = null;
    let deviceHeading = null;
    let closestIndex = 0;

    // í„´ ìŒì„± ì˜ˆê³  ì¤‘ë³µ ë°©ì§€
    const announced10 = new Set();
    const announced5 = new Set();
    const announcedTurnHere = new Set();

    // ì•„ì´ì½˜ ì •ì˜
    const blueIcon = L.icon({
      iconUrl: 'https://maps.google.com/mapfiles/ms/icons/blue-dot.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32]
    });
    const redIcon = L.icon({
      iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
      iconSize: [32, 32],
      iconAnchor: [16, 32]
    });

    // ìŒì„± ì•ˆë‚´ í•¨ìˆ˜
    function speak(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'ko-KR';
      speechSynthesis.speak(utterance);
    }

    // ë°©ìœ„ê° ê³„ì‚° í•¨ìˆ˜
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRad = deg => deg * Math.PI / 180;
      const toDeg = rad => rad * 180 / Math.PI;
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    // ë‚˜ì¹¨ë°˜ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ë‹¤ìŒ ë‹¨ê³„ì— ì—°ê²°)
    function drawCompass(targetAngle, tolerance, currentAngle) {
      const canvas = document.getElementById("compassCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 200, 200);

      const centerX = 100, centerY = 100, radius = 90;

      // ì™¸ê³½ ì›
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = "#555";
      ctx.lineWidth = 2;
      ctx.stroke();

      // ëª©í‘œ ë°©í–¥ ë²”ìœ„ (ì´ˆë¡ìƒ‰ ë¶€ì±„ê¼´)
      const startRad = ((targetAngle - tolerance + 360) % 360) * Math.PI / 180;
      const endRad = ((targetAngle + tolerance + 360) % 360) * Math.PI / 180;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, radius, startRad, endRad);
      ctx.lineTo(centerX, centerY);
      ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
      ctx.fill();

      // í˜„ì¬ ë°©í–¥ (ë¹¨ê°„ í™”ì‚´í‘œ)
      const angleRad = (currentAngle - 90) * Math.PI / 180;
      const x = centerX + radius * Math.cos(angleRad);
      const y = centerY + radius * Math.sin(angleRad);
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(x, y);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    function handleOrientation(event) {
      if (event.webkitCompassHeading !== undefined) {
        deviceHeading = event.webkitCompassHeading;
      } else if (event.alpha !== null) {
        deviceHeading = 360 - event.alpha;
      }
    }

    // ë°©í–¥ ì„¼ì„œ ê¶Œí•œ ìš”ì²­ (iOS ëŒ€ì‘)
    function requestSensorPermission() {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(state => {
            if (state === 'granted') {
              window.addEventListener("deviceorientation", handleOrientation);
              alert("ë°©í–¥ ì„¼ì„œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
            } else {
              alert("ë°©í–¥ ì„¼ì„œ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.");
            }
          })
          .catch(err => {
            alert("ê¶Œí•œ ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + err);
          });
      } else {
        // Android ë˜ëŠ” ë°ìŠ¤í¬íƒ‘
        window.addEventListener("deviceorientation", handleOrientation);
        alert("ë°©í–¥ ì„¼ì„œê°€ ìë™ìœ¼ë¡œ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
      }
    }

    document.getElementById("sensorBtn").addEventListener("click", requestSensorPermission);

    // í„´ ë¶„ì„ í•¨ìˆ˜: íšŒì „ í¬ì¸íŠ¸ ì¶”ì¶œ
    function analyzeTurns(coords) {
      const result = [];
      for (let i = 1; i < coords.length - 1; i++) {
        const [prevLat, prevLng] = coords[i - 1];
        const [currLat, currLng] = coords[i];
        const [nextLat, nextLng] = coords[i + 1];

        const bearing1 = calculateBearing(prevLat, prevLng, currLat, currLng);
        const bearing2 = calculateBearing(currLat, currLng, nextLat, nextLng);
        let diff = bearing2 - bearing1;
        if (diff > 180) diff -= 360;
        if (diff < -180) diff += 360;

        if (Math.abs(diff) >= 30) {
          result.push({
            index: i,
            location: [currLat, currLng],
            type: diff > 0 ? 'ìš°íšŒì „' : 'ì¢ŒíšŒì „',
            angle: diff
          });
        }
      }
      return result;
    }

    // ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜ (ë‹¨ìˆœ ìœ í´ë¦¬ë“œ)
    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth radius in m
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // í„´ ì˜ˆê³  ë° ì§€ì  ë„ë‹¬ ì‹œ ë‚˜ì¹¨ë°˜ ì•ˆë‚´
    function checkTurnAnnouncements() {
      if (!currentLatLng || turnPoints.length === 0) return;

      for (const turn of turnPoints) {
        const d = distance(currentLatLng[0], currentLatLng[1], turn.location[0], turn.location[1]);

        if (d < 12 && !announcedTurnHere.has(turn.index)) {
          announcedTurnHere.add(turn.index);
          speak(`ì—¬ê¸°ì„œ ${turn.type} í•˜ì„¸ìš”.`);
          fixedTargetAngle = calculateBearing(
            currentLatLng[0], currentLatLng[1],
            turn.location[0], turn.location[1]
          );
          if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
        } else if (d < 5 && !announced5.has(turn.index)) {
          announced5.add(turn.index);
          speak(`5ë¯¸í„° ì•ì—ì„œ ${turn.type} í•˜ì„¸ìš”.`);
        } else if (d < 10 && !announced10.has(turn.index)) {
          announced10.add(turn.index);
          speak(`10ë¯¸í„° ì•ì—ì„œ ${turn.type} í•˜ì„¸ìš”.`);
        }
      }
    }

    // ë°©í–¥ í™•ì¸ ë° ë‚˜ì¹¨ë°˜ ì •ë ¬ ì•ˆë‚´
    function updateCompassIfReady() {
      if (deviceHeading === null || fixedTargetAngle === null) return;
      const diff = Math.abs(fixedTargetAngle - deviceHeading);
      const angleDiff = Math.min(diff, 360 - diff);
      drawCompass(fixedTargetAngle, 30, deviceHeading);

      if (angleDiff > 30) {
        speak("ë°©í–¥ì´ í‹€ë ¸ìŠµë‹ˆë‹¤. ê¸°ê¸°ë¥¼ ì²œì²œíˆ ëŒë ¤ì£¼ì„¸ìš”.");
      } else {
        speak("ë°©í–¥ì´ ë§ì•˜ìŠµë‹ˆë‹¤. ì´ë™í•˜ì„¸ìš”.");
        fixedTargetAngle = null; // ì •ë ¬ ì™„ë£Œ í›„ ì´ˆê¸°í™”
      }
    }
    function resetMap() {
      routeCoords = [];
      turnPoints = [];
      if (routeLine) map.removeLayer(routeLine);
      if (traveledLine) map.removeLayer(traveledLine);
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);
      routeLine = null;
      traveledLine = null;
      startMarker = null;
      endMarker = null;
      currentMarker = null;
      fixedTargetAngle = null;
      closestIndex = 0;
      announced10.clear();
      announced5.clear();
      announcedTurnHere.clear();
      document.getElementById("progress-box").innerText = "ì§„í–‰ë¥ : -";

      if (currentLatLng) {
        startMarker = L.marker(currentLatLng, { icon: blueIcon }).addTo(map);
        speak("ì¶œë°œì§€ë¡œ í˜„ì¬ ìœ„ì¹˜ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ë„ì°©ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
      }
    }

    function getRoute(start, end) {
      const url = `https://router.project-osrm.org/route/v1/walking/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          const coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
          routeCoords = coords;
          routeLine = L.polyline(coords, { color: 'blue' }).addTo(map);
          map.fitBounds(routeLine.getBounds());
          speak("ê²½ë¡œë¥¼ ì•ˆë‚´í•©ë‹ˆë‹¤. ì²« ë°©í–¥ì„ í™•ì¸í•˜ì„¸ìš”.");
          turnPoints = analyzeTurns(routeCoords);
        });
    }

    map.on('click', function(e) {
      if (!endMarker && startMarker) {
        endMarker = L.marker(e.latlng, { icon: redIcon }).addTo(map);
        const start = [startMarker.getLatLng().lat, startMarker.getLatLng().lng];
        const end = [e.latlng.lat, e.latlng.lng];
        getRoute(start, end);
      }
    });

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(pos => {
        currentLatLng = [pos.coords.latitude, pos.coords.longitude];

        if (!currentMarker) {
          currentMarker = L.marker(currentLatLng).addTo(map);
          map.setView(currentLatLng, 16);

          if (!startMarker) {
            startMarker = L.marker(currentLatLng, { icon: blueIcon }).addTo(map);
            speak("í˜„ì¬ ìœ„ì¹˜ê°€ ì¶œë°œì§€ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. ë„ì°©ì§€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
          }
        } else {
          currentMarker.setLatLng(currentLatLng);
        }

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        if (routeCoords.length > 1) {
          let minDist = Infinity;
          for (let i = 0; i < routeCoords.length; i++) {
            const d = distance(currentLatLng[0], currentLatLng[1], routeCoords[i][0], routeCoords[i][1]);
            if (d < minDist) {
              minDist = d;
              closestIndex = i;
            }
          }

          const progress = Math.round((closestIndex / (routeCoords.length - 1)) * 100);
          document.getElementById("progress-box").innerText = `ì§„í–‰ë¥ : ${progress}%`;

          const traveled = routeCoords.slice(0, closestIndex + 1);
          if (traveledLine) traveledLine.setLatLngs(traveled);
          else traveledLine = L.polyline(traveled, { color: "green" }).addTo(map);

          checkTurnAnnouncements();
        }
      });
    }

    setInterval(updateCompassIfReady, 1500);
  </script>
</body>
</html>
